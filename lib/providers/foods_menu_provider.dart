import 'dart:convert';
import 'dart:developer';
import 'package:flutter/cupertino.dart';

//as http to avoid any name clashes
import 'package:http/http.dart' as http;

import '../models/app_exceptions.dart';
import '../providers/category_item_provider.dart';
import '../providers/food_category_provider.dart';

//FoodsMenu class, using Change Notifier to notify listeners of any changes made
//mixin is like merging classes (keyword is WITH)
class FoodsMenu with ChangeNotifier {
  //to store the user token
  final String _userToken;
  //to store the user ID
  final String _userID;
  //to store the list of FoodCategoryProvider items
  List<FoodCategoryProvider> _foodCategoryItems = [];
  //constructor
  FoodsMenu(this._userToken, this._userID, this._foodCategoryItems);
  //return list of FoodCategoryProvider items
  List<FoodCategoryProvider> get getCategoryItems {
    //return a copy of items
    //because data is not to be modified so just returns its copy
    return [..._foodCategoryItems];
  }
  //find food category by ID
  FoodCategoryProvider findCategoryById(String id) {
    return _foodCategoryItems.firstWhere((theFood) => theFood.id == id);
  }
  //find item in food category by ID
  CategoryItemProvider findItemById(String categoryId, String categoryItemID) {
    return findCategoryById(categoryId)
        .itemsInCategory
        .firstWhere((element) => element.id == categoryItemID);
  }
  //add category to the database
  Future<void> addFoodCategory(FoodCategoryProvider itemCategory) async {
    //sending request to this URL
    //debugPrint(currentUserToken);
    const String baseUrl =
        'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
        //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
    const String charactersPath = '/foods.json';
    final Map<String, String> queryParameters = <String, String>{
      'auth': _userToken,
    };
    final url = Uri.https(baseUrl, charactersPath, queryParameters);
    //url plus saying what type of data i want to send to the database, in this case map data
    try {
      final response = await http.post(
        url,
        body: json.encode({
          'ownerID': _userID,
          'title': itemCategory.title,
        }),
      );
      //print(json.decode(response.body));
      //runs after the data has been posted, when there is a response from database
      final newCategory = FoodCategoryProvider(
          //getting ID generated by Firebase
          id: json.decode(response.body)['name'],
          title: itemCategory.title,
          itemsInCategory: itemCategory.itemsInCategory);
      _foodCategoryItems.add(newCategory);
      //used by the providers package, establishes a communication channel between interested widgets and this class
      //let certain widgets know about the updates made, so only widgets listening to this class will get rebuilt
      notifyListeners();
    } catch (error) {
      //error handling
      debugPrint("error in add food category method : $error");
      //creating error to be handled by the other screen
      rethrow;
    }
  }
  //add category items to the database
  Future<void> addFoodItemCategory(
      String categoryID, CategoryItemProvider categoryItem) async {
    /*debugPrint('adding the category item');
    debugPrint(categoryItem.id);
    debugPrint(categoryItem.title);
    debugPrint(categoryItem.description);
    debugPrint(categoryItem.price.toString());*/
    const String baseUrl =
        'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
        //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
    var charactersPath = '/foods/$categoryID/itemsInCategory.json';
    final Map<String, String> queryParameters = <String, String>{
      'auth': _userToken,
    };
    final url = Uri.https(baseUrl, charactersPath, queryParameters);
    try {
      final response = await http.post(
        url,
        body: json.encode({
          'categoryID': categoryID,
          'itemTitle': categoryItem.categoryItemTitle,
          'itemDescription': categoryItem.categoryItemDescription,
          'itemPrice': categoryItem.categoryItemPrice,
        }),
      );
      final newCategoryItem = CategoryItemProvider(
        id: json.decode(response.body)['name'],
        categoryItemTitle: categoryItem.categoryItemTitle,
        categoryItemDescription: categoryItem.categoryItemDescription,
        categoryItemPrice: categoryItem.categoryItemPrice,
      );
      //findById(categoryID).add(newCategoryItem);
      findCategoryById(categoryID).itemsInCategory.add(newCategoryItem);
      //used by the providers package, establishes a communication channel between interested widgets and this class
      //let certain widgets know about the updates made, so only widgets listening to this class will get rebuilt
      notifyListeners();
    } catch (error) {
      //error handling
      debugPrint("error in add item in category method : $error");
      //creating error to be handled by the other screen
      rethrow;
    }
  }
  //update a food category stored on the database
  Future<void> updateFoodCategory(
      String foodID, FoodCategoryProvider newCategoryItem) async {
    final catIndex = _foodCategoryItems.indexWhere((category) => category.id == foodID);
    //check if a category with that index is found
    if (catIndex >= 0) {
      //updating data on the database
      const String baseUrl =
          'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
          //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
      var charactersPath = '/foods/$foodID.json';
      final Map<String, String> queryParameters = <String, String>{
        'auth': _userToken,
      };
      final url = Uri.https(baseUrl, charactersPath, queryParameters);
      try {
        //merge data with patch in firebase
        await http.patch(url,
            body: json.encode({
              'title': newCategoryItem.title,
            }));
        //overwrite that category
        _foodCategoryItems[catIndex] = newCategoryItem;
        notifyListeners();
      } catch (error) {
        //error handling
        debugPrint("error in update/edit category method : $error");
        //creating error to be handled by the other screen
        rethrow;
      }
    } else {
      debugPrint('No Category ID match found in Update Category');
    }
  }
  //update the item in food category on the database
  Future<void> updateFoodCategoryItem(String categoryID, String foodItemID,
      CategoryItemProvider newItem) async {
    //debugPrint('updating the category item');
    //updating data on the database
    const String baseUrl =
        'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
        //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
    var charactersPath = '/foods/$categoryID/itemsInCategory/$foodItemID.json';
    final Map<String, String> queryParameters = <String, String>{
      'auth': _userToken,
    };
    final url = Uri.https(baseUrl, charactersPath, queryParameters);
    final catIndex = findCategoryById(categoryID)
        .itemsInCategory
        .indexWhere((category) => category.id == foodItemID);
    //check if a category with that index is found
    if (catIndex >= 0) {
      //overwrite that category
      try {
        await http.patch(url,
            body: json.encode({
              'title': newItem.categoryItemTitle,
              'description': newItem.categoryItemDescription,
              'price': newItem.categoryItemPrice,
            }));
        findCategoryById(categoryID).itemsInCategory[catIndex] = newItem;
        //notify of changes made to the listeners
        notifyListeners();
      } catch (error) {
        //error handling
        debugPrint("error in update/edit category item method : $error");
        //creating error to be handled by the other screen
        rethrow;
      }
    } else {
      debugPrint('No Category ID match found in Update Category');
    }
  }

  //delete a category and all items within it
  Future<void> deleteFoodCategory(String foodID) async {
    const String baseUrl =
        'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
        //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
    var charactersPath = '/foods/$foodID.json';
    final Map<String, String> queryParameters = <String, String>{
      'auth': _userToken,
    };

    final url = Uri.https(baseUrl, charactersPath, queryParameters);
    try {
      //delete a category
      http.delete(url);
      _foodCategoryItems.removeWhere((theCategory) => theCategory.id == foodID);
      notifyListeners();
      //_items.removeWhere((theCategory) => theCategory.id == foodID);
      //notifyListeners();
    } catch (error) {
      //error handling
      debugPrint("error in delete category method : $error");
      //creating error to be handled by the other screen
      throw AppExceptions('Could not delete this category');
    }
  }
  //delete a specific item by ID
  void deleteCategoryItem(String categoryID, String itemID) {
    //updating data on the database
    const String baseUrl =
        'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
        //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
    var charactersPath = '/foods/$categoryID/itemsInCategory/$itemID.json';
    final Map<String, String> queryParameters = <String, String>{
      //'auth': currentUserToken,
      'auth': _userToken,
    };
    final url = Uri.https(baseUrl, charactersPath, queryParameters);
    try {
      http.delete(url);
      FoodCategoryProvider inCategory = findCategoryById(categoryID);
      inCategory.itemsInCategory.removeWhere((theItem) => theItem.id == itemID);
      notifyListeners();
    } catch (error) {
      //error handling
      debugPrint("error in delete category item method : $error");
      //creating error to be handled by the other screen
      throw AppExceptions('Could not delete this category item');
    }
  }
  //get all menu categories and items within for the current owner logged in
  Future<void> fetchAndSetMenu() async {
    //debugPrint('fetchAndSetMenu');
    //getting menu by owner ID
    const String baseUrl =
        'finalyearproject-6b240-default-rtdb.europe-west1.firebasedatabase.app';
        //'testing-dccdf-default-rtdb.europe-west1.firebasedatabase.app';
    const String charactersPath = '/foods.json';
    final Map<String, String> queryParameters = <String, String>{
      //'auth': currentUserToken,
      'auth': _userToken,
      'orderBy': '"ownerID"',
      'equalTo': '"$_userID"',
    };
    final url = Uri.https(baseUrl, charactersPath, queryParameters);
    try {
      //store data in response
      final response = await http.get(url);
      //debugPrint('getting data from database');
      final receivedData =
          json.decode(response.body.toString()) as Map<String, dynamic>?;
      if(receivedData==null){
        return;
      }
      //temporary list holder, to tell which kind of data
      final List<FoodCategoryProvider> loadedCategories = [];
      //key is the food category ID, value is data
      //extractedData.forEach((key, value) {
      receivedData.forEach((categoryID, categoryData) {
        //get each item in list and add to a list of type needed, then finally returning that list as a single variable
        //log(categoryData['itemsInCategory'].toString());
        List<CategoryItemProvider> itemsList = [];
        final itemsInCategoryList =
            categoryData['itemsInCategory'] as Map<String, dynamic>?;
        if (itemsInCategoryList != null) {
          itemsInCategoryList.forEach((itemID, itemData) {
            //debugPrint("Item ID got : "+itemID);
            //debugPrint('${"title of item : "+itemData['title']} : with ID: $itemID : with category ID: $categoryID');
            //itemsList.add(CategoryItemProvider(id: itemID, title: title, description: description, price: price))
            //('ELEMENT ID: '+ itemData['name']);
            CategoryItemProvider itemsListItem = CategoryItemProvider(
                id: itemID,
                categoryItemTitle: itemData['title'],
                categoryItemDescription: itemData['description'],
                categoryItemPrice: itemData['price']);
            itemsList.add(itemsListItem);
            //debugPrint(itemsList[0].title.toString());
          });
        } else {
          itemsList.add(CategoryItemProvider(
              id: 'null',
              categoryItemTitle: 'title',
              categoryItemDescription: 'description',
              categoryItemPrice: 0));
          //debugPrint('no items in this category ID: $categoryID');
        }
        loadedCategories.add(FoodCategoryProvider(
          id: categoryID,
          title: categoryData['title'],
          itemsInCategory: itemsList,
        ));
      });
      _foodCategoryItems = loadedCategories;

      //debugPrint(_items.toString());
      Future.delayed(const Duration(milliseconds: 500), () {
        //notify listeners of the changes made
        notifyListeners();
      });
      //notifyListeners();
    } catch (error) {
      //throw error to handle it
      rethrow;
    }
  }
}
